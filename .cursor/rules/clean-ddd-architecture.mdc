---
alwaysApply: true
---

# Clean DDD Architecture Structure Rule

This repository must follow a complete Domain-Driven Design (DDD) Clean Architecture pattern. All code must be organized following this exact structure and guidelines.

## ğŸ—ï¸ Module Structure

Each domain module must follow this exact folder structure:

```
{module-name}/
â”œâ”€â”€ {module-name}.module.ts                    # Main module orchestrator
â”œâ”€â”€ domain/                                    # Business logic layer
â”‚   â”œâ”€â”€ {module-name}-domain.module.ts        # Domain module definition
â”‚   â”œâ”€â”€ entities/                             # Domain entities and aggregates
â”‚   â”‚   â”œâ”€â”€ {entity-name}.ts
â”‚   â”‚   â”œâ”€â”€ {entity-name}.spec.ts
â”‚   â”‚   â””â”€â”€ {aggregate-root}.ts
â”‚   â”œâ”€â”€ value-objects/                        # Immutable value objects
â”‚   â”‚   â”œâ”€â”€ {module-name}-{property}.value-object.ts
â”‚   â”‚   â””â”€â”€ {module-name}-{property}.value-object.spec.ts
â”‚   â”œâ”€â”€ events/                               # Domain events
â”‚   â”‚   â”œâ”€â”€ {event-name}/
â”‚   â”‚   â”‚   â”œâ”€â”€ {event-name}.domain-event.ts
â”‚   â”‚   â”‚   â””â”€â”€ {event-name}.domain-event.spec.ts
â”‚   â”œâ”€â”€ exceptions/                           # Domain-specific exceptions
â”‚   â”‚   â”œâ”€â”€ {exception-name}.exception.ts
â”‚   â”‚   â””â”€â”€ {exception-name}.exception.spec.ts
â”‚   â”œâ”€â”€ factories/                            # Domain object factories
â”‚   â”‚   â”œâ”€â”€ {entity-name}.factory.ts
â”‚   â”‚   â””â”€â”€ {entity-name}.factory.spec.ts
â”‚   â”œâ”€â”€ services/                             # Domain services
â”‚   â”‚   â”œâ”€â”€ {service-name}.domain-service.ts
â”‚   â”‚   â””â”€â”€ {service-name}.domain-service.spec.ts
â”‚   â”œâ”€â”€ primitives/                           # Domain primitives
â”‚   â”‚   â””â”€â”€ {module-name}.primitives.ts
â”‚   â””â”€â”€ constants/                            # Domain constants
â”‚       â””â”€â”€ {module-name}.constants.ts
â”œâ”€â”€ application/                              # Use cases and orchestration
â”‚   â”œâ”€â”€ {module-name}-application.module.ts  # Application module definition
â”‚   â”œâ”€â”€ commands/                             # Command handlers (CQRS)
â”‚   â”‚   â”œâ”€â”€ {use-case-name}/
â”‚   â”‚   â”‚   â”œâ”€â”€ {use-case-name}.command.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ {use-case-name}.command-handler.ts
â”‚   â”‚   â”‚   â””â”€â”€ {use-case-name}.command-handler.spec.ts
â”‚   â”œâ”€â”€ queries/                              # Query handlers (CQRS)
â”‚   â”‚   â”œâ”€â”€ {query-name}/
â”‚   â”‚   â”‚   â”œâ”€â”€ {query-name}.query.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ {query-name}.query-handler.ts
â”‚   â”‚   â”‚   â””â”€â”€ {query-name}.query-handler.spec.ts
â”‚   â”œâ”€â”€ event-handlers/                       # Application event handlers
â”‚   â”‚   â”œâ”€â”€ {event-name}/
â”‚   â”‚   â”‚   â”œâ”€â”€ {event-name}.event-handler.ts
â”‚   â”‚   â”‚   â””â”€â”€ {event-name}.event-handler.spec.ts
â”‚   â”œâ”€â”€ dtos/                                 # Data Transfer Objects
â”‚   â”‚   â”œâ”€â”€ {dto-name}.dto.ts
â”‚   â”‚   â””â”€â”€ {dto-name}.dto.spec.ts
â”‚   â”œâ”€â”€ ports/                                # Interface definitions (Dependency Inversion)
â”‚   â”‚   â”œâ”€â”€ {repository-name}.repository.ts
â”‚   â”‚   â”œâ”€â”€ {service-name}.service.ts
â”‚   â”‚   â””â”€â”€ {gateway-name}.gateway.ts
â”‚   â”œâ”€â”€ services/                             # Application services
â”‚   â”‚   â”œâ”€â”€ {service-name}.service.ts
â”‚   â”‚   â””â”€â”€ {service-name}.service.spec.ts
â”‚   â””â”€â”€ events/                               # Application events
â”‚       â”œâ”€â”€ {event-name}.event.ts
â”‚       â””â”€â”€ {event-name}.event.spec.ts
â”œâ”€â”€ infrastructure/                           # External concerns implementation
â”‚   â”œâ”€â”€ {module-name}-infrastructure.module.ts # Infrastructure module definition
â”‚   â”œâ”€â”€ persistance/                          # Data persistence implementations
â”‚   â”‚   â”œâ”€â”€ in-memory/
â”‚   â”‚   â”‚   â”œâ”€â”€ in-memory-persistance.module.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ {entity-name}-in-memory.entity.ts
â”‚   â”‚   â”‚   â””â”€â”€ repositories/
â”‚   â”‚   â”‚       â””â”€â”€ {repository-name}-in-memory.repository.ts
â”‚   â”‚   â””â”€â”€ prisma/
â”‚   â”‚       â”œâ”€â”€ prisma-persistance.module.ts
â”‚   â”‚       â”œâ”€â”€ entities/
â”‚   â”‚       â”‚   â””â”€â”€ {entity-name}-prisma.entity.ts
â”‚   â”‚       â””â”€â”€ repositories/
â”‚   â”‚           â””â”€â”€ {repository-name}-prisma.repository.ts
â”‚   â”œâ”€â”€ cache/                                # Caching implementations
â”‚   â”‚   â”œâ”€â”€ noop/
â”‚   â”‚   â”‚   â””â”€â”€ noop-cache.module.ts
â”‚   â”‚   â”œâ”€â”€ in-memory/
â”‚   â”‚   â”‚   â””â”€â”€ in-memory-cache.module.ts
â”‚   â”‚   â””â”€â”€ redis/
â”‚   â”‚       â””â”€â”€ redis-cache.module.ts
â”‚   â”œâ”€â”€ services/                             # External service implementations
â”‚   â”‚   â”œâ”€â”€ {service-name}.service.impl.ts
â”‚   â”‚   â””â”€â”€ {service-name}.service.impl.spec.ts
â”‚   â”œâ”€â”€ decorators/                           # Infrastructure decorators
â”‚   â”‚   â””â”€â”€ {decorator-name}.decorator.ts
â”‚   â”œâ”€â”€ guards/                               # Security guards
â”‚   â”‚   â”œâ”€â”€ {guard-name}/
â”‚   â”‚   â”‚   â”œâ”€â”€ {guard-name}.guard.ts
â”‚   â”‚   â”‚   â””â”€â”€ {guard-name}.guard.spec.ts
â”‚   â””â”€â”€ providers/                            # External providers (APIs, etc.)
â”‚       â””â”€â”€ {provider-name}/
â”‚           â”œâ”€â”€ {provider-name}.provider.ts
â”‚           â””â”€â”€ {provider-name}.provider.spec.ts
â””â”€â”€ presenters/                               # Interface adapters
    â””â”€â”€ http/                                 # HTTP controllers
        â”œâ”€â”€ controllers/
        â”‚   â”œâ”€â”€ {controller-name}.controller.ts
        â”‚   â””â”€â”€ {controller-name}.controller.spec.ts
        â”œâ”€â”€ dtos/
        â”‚   â”œâ”€â”€ requests/
        â”‚   â”‚   â””â”€â”€ {request-name}.request.dto.ts
        â”‚   â””â”€â”€ responses/
        â”‚       â””â”€â”€ {response-name}.response.dto.ts
        â””â”€â”€ guards/
            â”œâ”€â”€ {guard-name}.guard.ts
            â””â”€â”€ {guard-name}.guard.spec.ts
    â””â”€â”€ graphql/                                 # Graphql
      â”œâ”€â”€ resolvers/
      â”‚   â”œâ”€â”€ {resolver-name}.resolver.ts
      â”‚   â””â”€â”€ {resolver-name}.resolver.spec.ts
      â”œâ”€â”€ dtos/
      â”‚   â”œâ”€â”€ requests/
      â”‚   â”‚   â””â”€â”€ {request-name}.request.dto.ts
      â”‚   â””â”€â”€ responses/
      â”‚       â””â”€â”€ {response-name}.response.dto.ts
      â””â”€â”€ guards/
          â”œâ”€â”€ {guard-name}.guard.ts
          â””â”€â”€ {guard-name}.guard.spec.ts
```

## ğŸ“‹ Layer Responsibilities

### ğŸ›ï¸ Domain Layer

**Purpose**: Contains business logic and domain knowledge
**Dependencies**: None (pure business logic)

- **Entities**: Core business objects with identity and lifecycle
- **Value Objects**: Immutable objects defined by their properties
- **Domain Events**: Business events that occurred in the domain
- **Domain Services**: Business logic that doesn't belong to a single entity
- **Factories**: Complex object creation logic
- **Exceptions**: Domain-specific error conditions
- **Primitives**: Basic types used across the domain
- **Constants**: Domain-level constants

**Rules**:

- No dependencies on other layers
- Contains only business logic
- Entities must implement proper encapsulation
- Value Objects must be immutable
- All business rules must be enforced here

### ğŸ”„ Application Layer

**Purpose**: Orchestrates use cases and coordinates domain objects
**Dependencies**: Domain layer only

- **Commands/CommandHandlers**: Write operations (CQRS pattern)
- **Queries/QueryHandlers**: Read operations (CQRS pattern)
- **Event Handlers**: React to domain events
- **DTOs**: Data transfer between layers
- **Ports**: Interface definitions for external dependencies
- **Services**: Application-specific services
- **Events**: Application-level events

**Rules**:

- Orchestrates domain objects
- Implements use cases
- Depends only on domain layer
- Defines interfaces for infrastructure (ports)
- No business logic, only coordination

### ğŸ”§ Infrastructure Layer

**Purpose**: Implements technical concerns and external dependencies
**Dependencies**: Application and Domain layers

- **Persistence**: Database implementations
- **Cache**: Caching strategies
- **Services**: External service implementations
- **Providers**: Third-party integrations
- **Decorators**: Cross-cutting concerns
- **Guards**: Security implementations

**Rules**:

- Implements ports defined in application layer
- Contains all framework-specific code
- Handles external integrations
- Must be swappable through dependency injection

### ğŸŒ Presenters Layer

**Purpose**: Handles external interfaces (HTTP, GraphQL, CLI, etc.)
**Dependencies**: Application layer only

- **Controllers**: HTTP endpoint handlers
- **Resolvers**: GrapQL resolver handlers
- **DTOs**: Input/output data structures
- **Guards**: Presentation-level security
- **Middleware**: Request/response processing

**Rules**:

- Only input/output mapping
- No business logic
- Depends only on application layer
- Handles serialization/deserialization

## ğŸ”§ Module Integration Pattern

Each module must implement this integration pattern:

```typescript
// Main module
@Module({})
export class {ModuleName}Module {
  static forRoot(options: ApplicationBootstrapOptions): DynamicModule {
    return {
      module: {ModuleName}Module,
      imports: [
        {ModuleName}DomainModule,
        {ModuleName}ApplicationModule,
        {ModuleName}InfrastructureModule.use(
          options.databaseDriver,
          options.cacheDriver,
        ),
      ],
      exports: [{ModuleName}ApplicationModule, {ModuleName}InfrastructureModule],
    };
  }
}

// Application module
@Module({})
export class {ModuleName}ApplicationModule {
  static withInfrastructure(
    infrastructureModule: Type | DynamicModule,
    options: ApplicationBootstrapOptions,
  ) {
    return {
      module: {ModuleName}ApplicationModule,
      imports: [infrastructureModule],
    };
  }
}

// Infrastructure module
@Module({})
export class {ModuleName}InfrastructureModule {
  static use(
    databaseDriver: 'in-memory' | 'type-orm',
    cacheDriver: 'in-memory' | 'noop' | 'redis',
  ) {
    const persistenceModule = this.selectPersistenceModule(databaseDriver);
    const cacheModule = this.selectCacheModule(cacheDriver);

    return {
      module: {ModuleName}InfrastructureModule,
      imports: [persistenceModule, cacheModule],
      exports: [persistenceModule, cacheModule],
    };
  }
}
```

## ğŸ“‚ Shared Components Structure

```
shared/
â”œâ”€â”€ shared.module.ts
â”œâ”€â”€ domain/
â”‚   â””â”€â”€ exceptions/
â”‚       â””â”€â”€ domain.exception.ts           # Base domain exception
â”œâ”€â”€ infrastructure/
â”‚   â”œâ”€â”€ shared-infrastructure.module.ts
â”‚   â”œâ”€â”€ filters/
â”‚   â”‚   â””â”€â”€ domain-exception.filter.ts   # Global exception filter
â”‚   â””â”€â”€ redis/
â”‚       â””â”€â”€ redis.module.ts               # Shared Redis configuration
â””â”€â”€ common/
    â”œâ”€â”€ constants/
    â”‚   â””â”€â”€ currency.constant.ts          # Global constants
    â””â”€â”€ interfaces/
        â””â”€â”€ application-bootstrap-options.interface.ts
```

## ğŸ¯ Naming Conventions

- **Modules**: `{domain-name}.module.ts`
- **Entities**: `{entity-name}.ts`
- **Value Objects**: `{module-name}-{property-name}.value-object.ts`
- **Commands**: `{action-name}.command.ts`
- **Command Handlers**: `{action-name}.command-handler.ts`
- **Queries**: `{query-name}.query.ts`
- **Query Handlers**: `{query-name}.query-handler.ts`
- **Events**: `{event-name}.domain-event.ts`
- **Event Handlers**: `{event-name}.event-handler.ts`
- **Exceptions**: `{exception-name}.exception.ts`
- **DTOs**: `{purpose}.dto.ts`
- **Repositories**: `{entity-name}.repository.ts`
- **Services**: `{service-name}.service.ts`
- **Controllers**: `{resource-name}.controller.ts`

## ğŸ§ª Testing Strategy

Each component must have corresponding tests:

- **Unit Tests**: `.spec.ts` files alongside source files
- **Integration Tests**: `e2e` folder for end-to-end tests
- **Domain Tests**: Focus on business logic validation
- **Application Tests**: Test use case orchestration
- **Infrastructure Tests**: Test external integrations

## ğŸ“‹ Implementation Rules

1. **Dependency Direction**: Always inward (Infrastructure â†’ Application â†’ Domain)
2. **Interface Segregation**: Create specific interfaces for each use case
3. **Single Responsibility**: Each class/module has one reason to change
4. **Open/Closed**: Open for extension, closed for modification
5. **Dependency Inversion**: Depend on abstractions, not concretions
6. **Test Coverage**: Minimum 80% coverage for business logic
7. **Documentation**: JSDoc for all public methods and classes
8. **Error Handling**: Domain exceptions for business errors
9. **Event Sourcing**: Use domain events for state changes
10. **CQRS**: Separate read and write operations

This architecture ensures scalability, maintainability, and testability while following DDD principles and clean architecture patterns.
