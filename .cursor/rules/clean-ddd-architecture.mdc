---
description: Architecture porject description to build a DDD backend
alwaysApply: false
---

# Clean DDD Event-Driven Architecture Structure Rule

This repository must follow a complete Domain-Driven Design (DDD) Clean Architecture pattern with advanced Event-Driven Architecture patterns for distributed systems using Kafka and similar messaging platforms. All code must be organized following this exact structure and guidelines.

## ğŸ—ï¸ Module Structure

Each domain module must follow this exact folder structure:

```
{module-name}/
â”œâ”€â”€ {module-name}.module.ts                    # Main module orchestrator
â”œâ”€â”€ domain/                                    # Business logic layer
â”‚   â”œâ”€â”€ {module-name}-domain.module.ts        # Domain module definition
â”‚   â”œâ”€â”€ entities/                             # Domain entities and aggregates
â”‚   â”‚   â”œâ”€â”€ {entity-name}.entity.ts
â”‚   â”‚   â”œâ”€â”€ {entity-name}.entity.spec.ts
â”‚   â”‚   â””â”€â”€ {aggregate-root}.aggregate-root.ts
â”‚   â”œâ”€â”€ value-objects/                        # Immutable value objects
â”‚   â”‚   â”œâ”€â”€ {property}/
â”‚   â”‚       â”œâ”€â”€ {module-name}-{property}.value-object.ts
â”‚   â”‚       â””â”€â”€ {module-name}-{property}.value-object.spec.ts
â”‚   â”œâ”€â”€ events/                               # Domain events
â”‚   â”‚   â”œâ”€â”€ {event-name}/
â”‚   â”‚   â”‚   â”œâ”€â”€ {event-name}.domain-event.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ {event-name}.domain-event.spec.ts
â”‚   â”‚   â”‚   â””â”€â”€ {event-name}.schema.ts         # Event schema definition
â”‚   â”œâ”€â”€ exceptions/                           # Domain-specific exceptions
â”‚   â”‚   â”œâ”€â”€ {exception-name}/
â”‚   â”‚       â”œâ”€â”€ {exception-name}.exception.ts
â”‚   â”‚       â””â”€â”€ {exception-name}.exception.spec.ts
â”‚   â”œâ”€â”€ factories/                            # Domain object factories
â”‚   â”‚   â”œâ”€â”€ {entity-name}.factory.ts
â”‚   â”‚   â””â”€â”€ {entity-name}.factory.spec.ts
â”‚   â”œâ”€â”€ services/                             # Domain services
â”‚   â”‚   â”œâ”€â”€ {service-name}.domain-service.ts
â”‚   â”‚   â””â”€â”€ {service-name}.domain-service.spec.ts
â”‚   â”œâ”€â”€ primitives/                           # Domain primitives
â”‚   â”‚   â””â”€â”€ {module-name}.primitives.ts
â”‚   â”œâ”€â”€ constants/                            # Domain constants
â”‚   â”‚   â””â”€â”€ {module-name}.constants.ts
â”‚   â””â”€â”€ aggregates/                           # Aggregate specifications
â”‚       â”œâ”€â”€ {aggregate-name}.aggregate.ts
â”‚       â””â”€â”€ {aggregate-name}.aggregate.spec.ts
â”œâ”€â”€ application/                              # Use cases and orchestration
â”‚   â”œâ”€â”€ {module-name}-application.module.ts  # Application module definition
â”‚   â”œâ”€â”€ commands/                             # Command handlers (CQRS)
â”‚   â”‚   â”œâ”€â”€ {use-case-name}/
â”‚   â”‚   â”‚   â”œâ”€â”€ {use-case-name}.command.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ {use-case-name}.command-handler.ts
â”‚   â”‚   â”‚   â””â”€â”€ {use-case-name}.command-handler.spec.ts
â”‚   â”œâ”€â”€ queries/                              # Query handlers (CQRS)
â”‚   â”‚   â”œâ”€â”€ {query-name}/
â”‚   â”‚   â”‚   â”œâ”€â”€ {query-name}.query.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ {query-name}.query-handler.ts
â”‚   â”‚   â”‚   â””â”€â”€ {query-name}.query-handler.spec.ts
â”‚   â”œâ”€â”€ event-handlers/                       # Application event handlers
â”‚   â”‚   â”œâ”€â”€ {event-name}/
â”‚   â”‚   â”‚   â”œâ”€â”€ {event-name}.event-handler.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ {event-name}.event-handler.spec.ts
â”‚   â”‚   â”‚   â””â”€â”€ {event-name}.retry-policy.ts   # Retry and error handling
â”‚   â”œâ”€â”€ sagas/                                # Distributed transaction orchestrators
â”‚   â”‚   â”œâ”€â”€ {saga-name}/
â”‚   â”‚   â”‚   â”œâ”€â”€ {saga-name}.saga.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ {saga-name}.saga.spec.ts
â”‚   â”‚   â”‚   â””â”€â”€ {saga-name}.state.ts           # Saga state management
â”‚   â”œâ”€â”€ projections/                          # Read model projections
â”‚   â”‚   â”œâ”€â”€ {projection-name}/
â”‚   â”‚   â”‚   â”œâ”€â”€ {projection-name}.projection.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ {projection-name}.projection.spec.ts
â”‚   â”‚   â”‚   â””â”€â”€ {projection-name}.rebuilder.ts # Projection rebuilding logic
â”‚   â”œâ”€â”€ dtos/                                 # Data Transfer Objects
â”‚   â”‚   â”œâ”€â”€ {dto-name}.dto.ts
â”‚   â”‚   â””â”€â”€ {dto-name}.dto.spec.ts
â”‚   â”œâ”€â”€ ports/                                # Interface definitions (Dependency Inversion)
â”‚   â”‚   â”œâ”€â”€ {repository-name}.repository.ts
â”‚   â”‚   â”œâ”€â”€ {service-name}.service.ts
â”‚   â”‚   â”œâ”€â”€ {gateway-name}.gateway.ts
â”‚   â”‚   â”œâ”€â”€ event-store.repository.ts         # Event store interface
â”‚   â”‚   â”œâ”€â”€ event-bus.service.ts              # Event bus interface
â”‚   â”‚   â”œâ”€â”€ message-broker.service.ts         # Message broker interface
â”‚   â”‚   â””â”€â”€ saga-store.repository.ts          # Saga persistence interface
â”‚   â”œâ”€â”€ services/                             # Application services
â”‚   â”‚   â”œâ”€â”€ {service-name}.service.ts
â”‚   â”‚   â”œâ”€â”€ {service-name}.service.spec.ts
â”‚   â”‚   â”œâ”€â”€ event-sourcing.service.ts         # Event sourcing coordination
â”‚   â”‚   â””â”€â”€ idempotency.service.ts            # Idempotency handling
â”‚   â”œâ”€â”€ events/                               # Application events
â”‚   â”‚   â”œâ”€â”€ {event-name}.event.ts
â”‚   â”‚   â”œâ”€â”€ {event-name}.event.spec.ts
â”‚   â”‚   â””â”€â”€ {event-name}.integration-event.ts # Cross-bounded context events
â”‚   â””â”€â”€ policies/                             # Event processing policies
â”‚       â”œâ”€â”€ retry.policy.ts
â”‚       â”œâ”€â”€ dead-letter.policy.ts
â”‚       â””â”€â”€ idempotency.policy.ts
â”œâ”€â”€ infrastructure/                           # External concerns implementation
â”‚   â”œâ”€â”€ {module-name}-infrastructure.module.ts # Infrastructure module definition
â”‚   â”œâ”€â”€ persistance/                          # Data persistence implementations
â”‚   â”‚   â”œâ”€â”€ in-memory/
â”‚   â”‚   â”‚   â”œâ”€â”€ in-memory-persistance.module.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ {entity-name}-in-memory.entity.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ {repository-name}-in-memory.repository.ts
â”‚   â”‚   â”‚   â””â”€â”€ event-store/
â”‚   â”‚   â”‚       â””â”€â”€ in-memory-event-store.repository.ts
â”‚   â”‚   â”œâ”€â”€ prisma/
â”‚   â”‚   â”‚   â”œâ”€â”€ prisma-persistance.module.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ {entity-name}-prisma.entity.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ {repository-name}-prisma.repository.ts
â”‚   â”‚   â”‚   â””â”€â”€ event-store/
â”‚   â”‚   â”‚       â”œâ”€â”€ prisma-event-store.repository.ts
â”‚   â”‚   â”‚       â””â”€â”€ outbox.entity.ts          # Outbox pattern implementation
â”‚   â”‚   â””â”€â”€ event-sourcing/
â”‚   â”‚       â”œâ”€â”€ event-sourcing.module.ts
â”‚   â”‚       â”œâ”€â”€ repositories/
â”‚   â”‚       â”‚   â”œâ”€â”€ event-store.repository.impl.ts
â”‚   â”‚       â”‚   â””â”€â”€ snapshot-store.repository.impl.ts
â”‚   â”‚       â””â”€â”€ services/
â”‚   â”‚           â”œâ”€â”€ event-replay.service.impl.ts
â”‚   â”‚           â””â”€â”€ snapshot.service.impl.ts
â”‚   â”œâ”€â”€ messaging/                            # Event and message handling
â”‚   â”‚   â”œâ”€â”€ kafka/
â”‚   â”‚   â”‚   â”œâ”€â”€ kafka-messaging.module.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ producers/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ kafka-event-publisher.service.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ kafka-command-publisher.service.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ consumers/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ kafka-event-consumer.service.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ kafka-dead-letter-consumer.service.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ kafka.config.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ topic.config.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ consumer-group.config.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ serializers/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ avro.serializer.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ json.serializer.ts
â”‚   â”‚   â”‚   â””â”€â”€ middleware/
â”‚   â”‚   â”‚       â”œâ”€â”€ retry.middleware.ts
â”‚   â”‚   â”‚       â”œâ”€â”€ dead-letter.middleware.ts
â”‚   â”‚   â”‚       â””â”€â”€ idempotency.middleware.ts
â”‚   â”‚   â”œâ”€â”€ in-memory/
â”‚   â”‚   â”‚   â”œâ”€â”€ in-memory-messaging.module.ts
â”‚   â”‚   â”‚   â””â”€â”€ in-memory-event-bus.service.ts
â”‚   â”‚   â””â”€â”€ rabbitmq/                         # Alternative messaging system
â”‚   â”‚       â”œâ”€â”€ rabbitmq-messaging.module.ts
â”‚   â”‚       â””â”€â”€ rabbitmq-event-bus.service.ts
â”‚   â”œâ”€â”€ cache/                                # Caching implementations
â”‚   â”‚   â”œâ”€â”€ noop/
â”‚   â”‚   â”‚   â””â”€â”€ noop-cache.module.ts
â”‚   â”‚   â”œâ”€â”€ in-memory/
â”‚   â”‚   â”‚   â””â”€â”€ in-memory-cache.module.ts
â”‚   â”‚   â””â”€â”€ redis/
â”‚   â”‚       â”œâ”€â”€ redis-cache.module.ts
â”‚   â”‚       â””â”€â”€ redis-projection-cache.service.ts # Projection caching
â”‚   â”œâ”€â”€ monitoring/                           # Observability implementations
â”‚   â”‚   â”œâ”€â”€ metrics/
â”‚   â”‚   â”‚   â”œâ”€â”€ event-metrics.service.ts
â”‚   â”‚   â”‚   â””â”€â”€ saga-metrics.service.ts
â”‚   â”‚   â””â”€â”€ tracing/
â”‚   â”‚       â”œâ”€â”€ event-tracing.service.ts
â”‚   â”‚       â””â”€â”€ distributed-tracing.service.ts
â”‚   â”œâ”€â”€ schema-registry/                      # Event schema management
â”‚   â”‚   â”œâ”€â”€ avro/
â”‚   â”‚   â”‚   â”œâ”€â”€ avro-schema-registry.module.ts
â”‚   â”‚   â”‚   â””â”€â”€ avro-schema-registry.service.ts
â”‚   â”‚   â””â”€â”€ json-schema/
â”‚   â”‚       â””â”€â”€ json-schema-registry.service.ts
â”‚   â”œâ”€â”€ services/                             # External service implementations
â”‚   â”‚   â”œâ”€â”€ {service-name}.service.impl.ts
â”‚   â”‚   â””â”€â”€ {service-name}.service.impl.spec.ts
â”‚   â”œâ”€â”€ decorators/                           # Infrastructure decorators
â”‚   â”‚   â”œâ”€â”€ {decorator-name}.decorator.ts
â”‚   â”‚   â”œâ”€â”€ transactional.decorator.ts
â”‚   â”‚   â”œâ”€â”€ idempotent.decorator.ts
â”‚   â”‚   â””â”€â”€ saga-orchestrates.decorator.ts
â”‚   â”œâ”€â”€ guards/                               # Security guards
â”‚   â”‚   â”œâ”€â”€ {guard-name}/
â”‚   â”‚   â”‚   â”œâ”€â”€ {guard-name}.guard.ts
â”‚   â”‚   â”‚   â””â”€â”€ {guard-name}.guard.spec.ts
â”‚   â”‚   â””â”€â”€ event-authorization.guard.ts
â”‚   â””â”€â”€ providers/                            # External providers (APIs, etc.)
â”‚       â””â”€â”€ {provider-name}/
â”‚           â”œâ”€â”€ {provider-name}.provider.ts
â”‚           â””â”€â”€ {provider-name}.provider.spec.ts
â””â”€â”€ presenters/                               # Interface adapters
    â”œâ”€â”€ http/                                 # HTTP controllers
    â”‚   â”œâ”€â”€ controllers/
    â”‚   â”‚   â”œâ”€â”€ {controller-name}.controller.ts
    â”‚   â”‚   â””â”€â”€ {controller-name}.controller.spec.ts
    â”‚   â”œâ”€â”€ dtos/
    â”‚   â”‚   â”œâ”€â”€ requests/
    â”‚   â”‚   â”‚   â””â”€â”€ {request-name}.request.dto.ts
    â”‚   â”‚   â””â”€â”€ responses/
    â”‚   â”‚       â””â”€â”€ {response-name}.response.dto.ts
    â”‚   â”œâ”€â”€ guards/
    â”‚   â”‚   â”œâ”€â”€ {guard-name}.guard.ts
    â”‚   â”‚   â””â”€â”€ {guard-name}.guard.spec.ts
    â”‚   â””â”€â”€ webhooks/                         # Webhook handlers for external events
    â”‚       â”œâ”€â”€ {webhook-name}.webhook.ts
    â”‚       â””â”€â”€ {webhook-name}.webhook.spec.ts
    â”œâ”€â”€ graphql/                              # GraphQL resolvers
    â”‚   â”œâ”€â”€ resolvers/
    â”‚   â”‚   â”œâ”€â”€ {resolver-name}.resolver.ts
    â”‚   â”‚   â””â”€â”€ {resolver-name}.resolver.spec.ts
    â”‚   â”œâ”€â”€ dtos/
    â”‚   â”‚   â”œâ”€â”€ requests/
    â”‚   â”‚   â”‚   â””â”€â”€ {request-name}.request.dto.ts
    â”‚   â”‚   â””â”€â”€ responses/
    â”‚   â”‚       â””â”€â”€ {response-name}.response.dto.ts
    â”‚   â”œâ”€â”€ guards/
    â”‚   â”‚   â”œâ”€â”€ {guard-name}.guard.ts
    â”‚   â”‚   â””â”€â”€ {guard-name}.guard.spec.ts
    â”‚   â””â”€â”€ subscriptions/                    # Real-time GraphQL subscriptions
    â”‚       â”œâ”€â”€ {subscription-name}.subscription.ts
    â”‚       â””â”€â”€ {subscription-name}.subscription.spec.ts
    â””â”€â”€ events/                               # Event-driven presenters
        â”œâ”€â”€ consumers/
        â”‚   â”œâ”€â”€ {event-consumer-name}.consumer.ts
        â”‚   â””â”€â”€ {event-consumer-name}.consumer.spec.ts
        â””â”€â”€ publishers/
            â”œâ”€â”€ {event-publisher-name}.publisher.ts
            â””â”€â”€ {event-publisher-name}.publisher.spec.ts
```

## ğŸ“‹ Layer Responsibilities

### ğŸ›ï¸ Domain Layer

**Purpose**: Contains business logic and domain knowledge
**Dependencies**: None (pure business logic)

- **Entities**: Core business objects with identity and lifecycle
- **Value Objects**: Immutable objects defined by their properties
- **Domain Events**: Business events that occurred in the domain with schemas
- **Aggregates**: Consistency boundaries and transaction boundaries
- **Domain Services**: Business logic that doesn't belong to a single entity
- **Factories**: Complex object creation logic
- **Exceptions**: Domain-specific error conditions
- **Primitives**: Basic types used across the domain
- **Constants**: Domain-level constants

**Rules**:

- No dependencies on other layers
- Contains only business logic
- Entities must implement proper encapsulation
- Value Objects must be immutable
- All business rules must be enforced here
- Aggregates define transaction boundaries
- Domain events must have versioned schemas

### ğŸ”„ Application Layer

**Purpose**: Orchestrates use cases and coordinates domain objects
**Dependencies**: Domain layer only

- **Commands/CommandHandlers**: Write operations (CQRS pattern)
- **Queries/QueryHandlers**: Read operations (CQRS pattern)
- **Event Handlers**: React to domain and integration events
- **Sagas**: Orchestrate distributed transactions and processes
- **Projections**: Build read models from event streams
- **DTOs**: Data transfer between layers
- **Ports**: Interface definitions for external dependencies
- **Services**: Application-specific services including event sourcing
- **Events**: Application-level and integration events
- **Policies**: Event processing, retry, and error handling policies

**Rules**:

- Orchestrates domain objects
- Implements use cases and business processes
- Depends only on domain layer
- Defines interfaces for infrastructure (ports)
- No business logic, only coordination
- Manages eventual consistency through events
- Implements saga patterns for distributed transactions
- Handles idempotency and exactly-once processing

### ğŸ”§ Infrastructure Layer

**Purpose**: Implements technical concerns and external dependencies
**Dependencies**: Application and Domain layers

- **Persistence**: Database implementations with event store
- **Messaging**: Kafka, RabbitMQ, and other message brokers
- **Event Sourcing**: Event store, snapshots, and replay mechanisms
- **Cache**: Caching strategies including projection caching
- **Schema Registry**: Event schema management and evolution
- **Monitoring**: Metrics, tracing, and observability
- **Services**: External service implementations
- **Providers**: Third-party integrations
- **Decorators**: Cross-cutting concerns (transactional, idempotent)
- **Guards**: Security implementations

**Rules**:

- Implements ports defined in application layer
- Contains all framework-specific code
- Handles external integrations
- Must be swappable through dependency injection
- Implements outbox pattern for transactional integrity
- Provides exactly-once delivery guarantees
- Handles schema evolution and backward compatibility
- Implements circuit breakers and retry mechanisms

### ğŸŒ Presenters Layer

**Purpose**: Handles external interfaces (HTTP, GraphQL, Events, CLI, etc.)
**Dependencies**: Application layer only

- **Controllers**: HTTP endpoint handlers
- **Resolvers**: GraphQL resolver handlers
- **Webhooks**: External system integration handlers
- **Event Consumers**: Kafka consumer handlers
- **Event Publishers**: Event publication interfaces
- **Subscriptions**: Real-time data subscriptions
- **DTOs**: Input/output data structures
- **Guards**: Presentation-level security
- **Middleware**: Request/response processing

**Rules**:

- Only input/output mapping
- No business logic
- Depends only on application layer
- Handles serialization/deserialization
- Manages event routing and transformation
- Implements at-least-once delivery semantics
- Provides idempotency keys for external consumers

## ğŸš€ Event-Driven Architecture Patterns

### ğŸ”„ Event Sourcing

```typescript
/**
 * Event sourcing implementation pattern
 * Store all changes as immutable events
 */
export interface EventStore {
  append(
    streamId: string,
    events: DomainEvent[],
    expectedVersion?: number,
  ): Promise<void>;
  getEvents(streamId: string, fromVersion?: number): Promise<DomainEvent[]>;
  getSnapshot(streamId: string): Promise<Snapshot | null>;
  saveSnapshot(streamId: string, snapshot: Snapshot): Promise<void>;
}

/**
 * Aggregate reconstruction from events
 */
export abstract class EventSourcedAggregate {
  protected version = 0;
  private uncommittedEvents: DomainEvent[] = [];

  static fromHistory<T extends EventSourcedAggregate>(
    events: DomainEvent[],
  ): T {
    const aggregate = new (this as any)();
    events.forEach((event) => aggregate.applyEvent(event));
    aggregate.version = events.length;
    return aggregate;
  }

  protected applyEvent(event: DomainEvent): void {
    this.apply(event);
    this.version++;
  }

  protected addEvent(event: DomainEvent): void {
    this.apply(event);
    this.uncommittedEvents.push(event);
  }

  getUncommittedEvents(): DomainEvent[] {
    return [...this.uncommittedEvents];
  }

  markEventsAsCommitted(): void {
    this.uncommittedEvents = [];
  }

  protected abstract apply(event: DomainEvent): void;
}
```

### ğŸ“¦ Outbox Pattern

```typescript
/**
 * Outbox pattern for transactional consistency
 * Ensures events are published exactly once
 */
@Entity()
export class OutboxEvent {
  @PrimaryColumn()
  id: string;

  @Column()
  aggregateId: string;

  @Column()
  eventType: string;

  @Column('json')
  eventData: object;

  @Column()
  createdAt: Date;

  @Column({ nullable: true })
  processedAt?: Date;

  @Column({ default: 0 })
  retryCount: number;
}

export class OutboxService {
  async publishUnprocessedEvents(): Promise<void> {
    const events = await this.outboxRepository.findUnprocessed();

    for (const event of events) {
      try {
        await this.eventBus.publish(event);
        await this.outboxRepository.markAsProcessed(event.id);
      } catch (error) {
        await this.outboxRepository.incrementRetry(event.id);
        if (event.retryCount >= MAX_RETRIES) {
          await this.deadLetterQueue.send(event);
        }
      }
    }
  }
}
```

### ğŸ­ Saga Pattern

```typescript
/**
 * Saga pattern for distributed transactions
 * Manages long-running business processes
 */
export abstract class Saga {
  protected sagaId: string;
  protected state: SagaState;
  protected compensations: Array<() => Promise<void>> = [];

  abstract handle(event: DomainEvent): Promise<void>;

  protected async executeStep<T>(
    action: () => Promise<T>,
    compensation: () => Promise<void>,
  ): Promise<T> {
    try {
      const result = await action();
      this.compensations.push(compensation);
      return result;
    } catch (error) {
      await this.compensate();
      throw error;
    }
  }

  protected async compensate(): Promise<void> {
    const compensations = [...this.compensations].reverse();

    for (const compensation of compensations) {
      try {
        await compensation();
      } catch (error) {
        // Log compensation failure but continue
        console.error('Compensation failed:', error);
      }
    }

    this.compensations = [];
  }
}
```

### ğŸ“Š Projection Pattern

```typescript
/**
 * Projection pattern for read models
 * Build optimized views from event streams
 */
export abstract class Projection {
  abstract readonly projectionName: string;

  abstract project(event: DomainEvent): Promise<void>;

  async rebuild(fromVersion?: number): Promise<void> {
    // Clear current projection
    await this.clear();

    // Replay all events
    const events = await this.eventStore.getAllEvents(fromVersion);

    for (const event of events) {
      await this.project(event);
    }
  }

  protected abstract clear(): Promise<void>;
}
```

## ğŸ”§ Module Integration Pattern

```typescript
// Main module with event-driven capabilities
@Module({})
export class {ModuleName}Module {
  static forRoot(options: ApplicationBootstrapOptions): DynamicModule {
    return {
      module: {ModuleName}Module,
      imports: [
        {ModuleName}DomainModule,
        {ModuleName}ApplicationModule,
        {ModuleName}InfrastructureModule.use(
          options.databaseDriver,
          options.cacheDriver,
          options.messagingDriver,
          options.eventSourcingEnabled,
        ),
      ],
      exports: [{ModuleName}ApplicationModule, {ModuleName}InfrastructureModule],
    };
  }
}

// Application module with saga and projection support
@Module({})
export class {ModuleName}ApplicationModule {
  static withInfrastructure(
    infrastructureModule: Type | DynamicModule,
    options: ApplicationBootstrapOptions,
  ) {
    const providers = [
      ...this.getCommandHandlers(),
      ...this.getQueryHandlers(),
      ...this.getEventHandlers(),
      ...this.getSagas(),
      ...this.getProjections(),
    ];

    return {
      module: {ModuleName}ApplicationModule,
      imports: [infrastructureModule],
      providers,
      exports: providers,
    };
  }

  private static getCommandHandlers(): Provider[] {
    return [
      // Command handlers
    ];
  }

  private static getQueryHandlers(): Provider[] {
    return [
      // Query handlers
    ];
  }

  private static getEventHandlers(): Provider[] {
    return [
      // Event handlers
    ];
  }

  private static getSagas(): Provider[] {
    return [
      // Saga orchestrators
    ];
  }

  private static getProjections(): Provider[] {
    return [
      // Projection builders
    ];
  }
}

// Infrastructure module with messaging support
@Module({})
export class {ModuleName}InfrastructureModule {
  static use(
    databaseDriver: 'in-memory' | 'prisma',
    cacheDriver: 'in-memory' | 'noop' | 'redis',
    messagingDriver: 'in-memory' | 'kafka' | 'rabbitmq',
    eventSourcingEnabled: boolean = false,
  ) {
    const persistenceModule = this.selectPersistenceModule(databaseDriver);
    const cacheModule = this.selectCacheModule(cacheDriver);
    const messagingModule = this.selectMessagingModule(messagingDriver);
    const eventSourcingModule = eventSourcingEnabled
      ? this.selectEventSourcingModule(databaseDriver)
      : null;

    return {
      module: {ModuleName}InfrastructureModule,
      imports: [
        persistenceModule,
        cacheModule,
        messagingModule,
        ...(eventSourcingModule ? [eventSourcingModule] : [])
      ],
      exports: [
        persistenceModule,
        cacheModule,
        messagingModule,
        ...(eventSourcingModule ? [eventSourcingModule] : [])
      ],
    };
  }

  private static selectMessagingModule(driver: string) {
    switch (driver) {
      case 'kafka':
        return KafkaMessagingModule;
      case 'rabbitmq':
        return RabbitMQMessagingModule;
      default:
        return InMemoryMessagingModule;
    }
  }

  private static selectEventSourcingModule(databaseDriver: string) {
    return EventSourcingModule.forDatabase(databaseDriver);
  }
}
```

## ğŸ“‚ Shared Components Structure

```
shared/
â”œâ”€â”€ shared.module.ts
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ exceptions/
â”‚   â”‚   â”œâ”€â”€ domain.exception.ts           # Base domain exception
â”‚   â”‚   â”œâ”€â”€ aggregate-not-found.exception.ts
â”‚   â”‚   â””â”€â”€ concurrency.exception.ts
â”‚   â”œâ”€â”€ events/
â”‚   â”‚   â”œâ”€â”€ domain-event.interface.ts
â”‚   â”‚   â”œâ”€â”€ integration-event.interface.ts
â”‚   â”‚   â””â”€â”€ event-metadata.ts
â”‚   â””â”€â”€ value-objects/
â”‚       â”œâ”€â”€ base.value-object.ts
â”‚       â”œâ”€â”€ event-id.value-object.ts
â”‚       â””â”€â”€ correlation-id.value-object.ts
â”œâ”€â”€ infrastructure/
â”‚   â”œâ”€â”€ shared-infrastructure.module.ts
â”‚   â”œâ”€â”€ filters/
â”‚   â”‚   â”œâ”€â”€ domain-exception.filter.ts   # Global exception filter
â”‚   â”‚   â””â”€â”€ event-exception.filter.ts
â”‚   â”œâ”€â”€ messaging/
â”‚   â”‚   â”œâ”€â”€ event-bus.interface.ts
â”‚   â”‚   â”œâ”€â”€ message-broker.interface.ts
â”‚   â”‚   â””â”€â”€ event-serializer.interface.ts
â”‚   â”œâ”€â”€ monitoring/
â”‚   â”‚   â”œâ”€â”€ metrics.service.ts
â”‚   â”‚   â””â”€â”€ distributed-tracing.service.ts
â”‚   â”œâ”€â”€ redis/
â”‚   â”‚   â””â”€â”€ redis.module.ts               # Shared Redis configuration
â”‚   â””â”€â”€ patterns/
â”‚       â”œâ”€â”€ outbox/
â”‚       â”‚   â”œâ”€â”€ outbox.module.ts
â”‚       â”‚   â””â”€â”€ outbox.service.ts
â”‚       â”œâ”€â”€ saga/
â”‚       â”‚   â”œâ”€â”€ saga.module.ts
â”‚       â”‚   â”œâ”€â”€ saga.orchestrator.ts
â”‚       â”‚   â””â”€â”€ saga-store.interface.ts
â”‚       â””â”€â”€ event-sourcing/
â”‚           â”œâ”€â”€ event-sourcing.module.ts
â”‚           â”œâ”€â”€ event-store.interface.ts
â”‚           â””â”€â”€ snapshot-store.interface.ts
â””â”€â”€ common/
    â”œâ”€â”€ constants/
    â”‚   â”œâ”€â”€ event-types.constant.ts        # Global event type constants
    â”‚   â”œâ”€â”€ topic-names.constant.ts        # Kafka topic names
    â”‚   â””â”€â”€ retry-policies.constant.ts
    â”œâ”€â”€ interfaces/
    â”‚   â”œâ”€â”€ application-bootstrap-options.interface.ts
    â”‚   â”œâ”€â”€ event-sourcing-options.interface.ts
    â”‚   â””â”€â”€ messaging-options.interface.ts
    â””â”€â”€ decorators/
        â”œâ”€â”€ event-handler.decorator.ts
        â”œâ”€â”€ saga-start.decorator.ts
        â”œâ”€â”€ saga-orchestrates.decorator.ts
        â””â”€â”€ projection.decorator.ts
```

## ğŸ¯ Naming Conventions

### Core Components

- **Modules**: `{domain-name}.module.ts`
- **Entities**: `{entity-name}.ts`
- **Aggregates**: `{aggregate-name}.aggregate.ts`
- **Value Objects**: `{module-name}-{property-name}.value-object.ts`

### CQRS Components

- **Commands**: `{action-name}.command.ts`
- **Command Handlers**: `{action-name}.command-handler.ts`
- **Queries**: `{query-name}.query.ts`
- **Query Handlers**: `{query-name}.query-handler.ts`

### Event-Driven Components

- **Domain Events**: `{event-name}.domain-event.ts`
- **Integration Events**: `{event-name}.integration-event.ts`
- **Event Handlers**: `{event-name}.event-handler.ts`
- **Event Schemas**: `{event-name}.schema.ts`

### Distributed Patterns

- **Sagas**: `{saga-name}.saga.ts`
- **Projections**: `{projection-name}.projection.ts`
- **Event Consumers**: `{consumer-name}.consumer.ts`
- **Event Publishers**: `{publisher-name}.publisher.ts`

### Infrastructure

- **Repositories**: `{entity-name}.repository.ts`
- **Services**: `{service-name}.service.ts`
- **Controllers**: `{resource-name}.controller.ts`
- **Middleware**: `{middleware-name}.middleware.ts`

## ğŸ§ª Testing Strategy

### Unit Testing

- **Domain Tests**: Focus on business logic and invariants
- **Application Tests**: Test use case orchestration and event handling
- **Infrastructure Tests**: Test external integrations and messaging

### Integration Testing

- **Event Flow Tests**: Test complete event flows across bounded contexts
- **Saga Tests**: Test distributed transaction scenarios
- **Projection Tests**: Test read model consistency

### End-to-End Testing

- **Message Replay Tests**: Test event replay scenarios
- **Failure Recovery Tests**: Test system resilience
- **Performance Tests**: Test under load with high event volumes

### Event-Specific Testing

```typescript
describe('Event Flow Testing', () => {
  it('should process events in correct order', async () => {
    // Arrange: Set up event stream
    const events = [event1, event2, event3];

    // Act: Process events
    await eventProcessor.processEvents(events);

    // Assert: Verify final state
    expect(await projectionRepository.getState()).toEqual(expectedState);
  });

  it('should handle event replay correctly', async () => {
    // Test projection rebuilding from events
  });

  it('should ensure exactly-once processing', async () => {
    // Test idempotency mechanisms
  });
});
```

## ğŸ“‹ Implementation Rules

### Core Architecture Rules

1. **Dependency Direction**: Always inward (Infrastructure â†’ Application â†’ Domain)
2. **Interface Segregation**: Create specific interfaces for each use case
3. **Single Responsibility**: Each class/module has one reason to change
4. **Open/Closed**: Open for extension, closed for modification
5. **Dependency Inversion**: Depend on abstractions, not concretions

### Event-Driven Rules

6. **Event Immutability**: Events must be immutable once created
7. **Event Versioning**: All events must support schema evolution
8. **Exactly-Once Processing**: Implement idempotency for all event handlers
9. **Event Ordering**: Maintain event ordering within aggregates
10. **Eventual Consistency**: Design for eventual consistency across bounded contexts

### Distributed System Rules

11. **Saga Isolation**: Sagas must handle concurrent execution
12. **Compensation Logic**: All saga steps must have compensation actions
13. **Circuit Breakers**: Implement circuit breakers for external dependencies
14. **Retry Policies**: Define clear retry and backoff strategies
15. **Dead Letter Queues**: Handle poison messages appropriately

### Observability Rules

16. **Distributed Tracing**: Trace requests across service boundaries
17. **Event Metrics**: Monitor event processing latency and throughput
18. **Saga Monitoring**: Track saga execution status and failures
19. **Projection Lag**: Monitor projection processing delays
20. **Schema Evolution**: Track schema changes and compatibility

This architecture ensures scalability, maintainability, and testability while following DDD principles, clean architecture patterns, and advanced event-driven architecture for distributed systems with Kafka and similar messaging platforms.

This architecture ensures scalability, maintainability, and testability while following DDD principles and clean architecture patterns.

# Clean DDD Event-Driven Architecture Structure Rule

This repository must follow a complete Domain-Driven Design (DDD) Clean Architecture pattern with advanced Event-Driven Architecture patterns for distributed systems using Kafka and similar messaging platforms. All code must be organized following this exact structure and guidelines.

## ğŸ—ï¸ Module Structure

Each domain module must follow this exact folder structure:

```
{module-name}/
â”œâ”€â”€ {module-name}.module.ts                    # Main module orchestrator
â”œâ”€â”€ domain/                                    # Business logic layer
â”‚   â”œâ”€â”€ {module-name}-domain.module.ts        # Domain module definition
â”‚   â”œâ”€â”€ entities/                             # Domain entities and aggregates
â”‚   â”‚   â”œâ”€â”€ {entity-name}.ts
â”‚   â”‚   â”œâ”€â”€ {entity-name}.spec.ts
â”‚   â”‚   â””â”€â”€ {aggregate-root}.ts
â”‚   â”œâ”€â”€ value-objects/                        # Immutable value objects
â”‚   â”‚   â”œâ”€â”€ {module-name}-{property}.value-object.ts
â”‚   â”‚   â””â”€â”€ {module-name}-{property}.value-object.spec.ts
â”‚   â”œâ”€â”€ events/                               # Domain events
â”‚   â”‚   â”œâ”€â”€ {event-name}/
â”‚   â”‚   â”‚   â”œâ”€â”€ {event-name}.domain-event.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ {event-name}.domain-event.spec.ts
â”‚   â”‚   â”‚   â””â”€â”€ {event-name}.schema.ts         # Event schema definition
â”‚   â”œâ”€â”€ exceptions/                           # Domain-specific exceptions
â”‚   â”‚   â”œâ”€â”€ {exception-name}.exception.ts
â”‚   â”‚   â””â”€â”€ {exception-name}.exception.spec.ts
â”‚   â”œâ”€â”€ factories/                            # Domain object factories
â”‚   â”‚   â”œâ”€â”€ {entity-name}.factory.ts
â”‚   â”‚   â””â”€â”€ {entity-name}.factory.spec.ts
â”‚   â”œâ”€â”€ services/                             # Domain services
â”‚   â”‚   â”œâ”€â”€ {service-name}.domain-service.ts
â”‚   â”‚   â””â”€â”€ {service-name}.domain-service.spec.ts
â”‚   â”œâ”€â”€ primitives/                           # Domain primitives
â”‚   â”‚   â””â”€â”€ {module-name}.primitives.ts
â”‚   â”œâ”€â”€ constants/                            # Domain constants
â”‚   â”‚   â””â”€â”€ {module-name}.constants.ts
â”‚   â””â”€â”€ aggregates/                           # Aggregate specifications
â”‚       â”œâ”€â”€ {aggregate-name}.aggregate.ts
â”‚       â””â”€â”€ {aggregate-name}.aggregate.spec.ts
â”œâ”€â”€ application/                              # Use cases and orchestration
â”‚   â”œâ”€â”€ {module-name}-application.module.ts  # Application module definition
â”‚   â”œâ”€â”€ commands/                             # Command handlers (CQRS)
â”‚   â”‚   â”œâ”€â”€ {use-case-name}/
â”‚   â”‚   â”‚   â”œâ”€â”€ {use-case-name}.command.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ {use-case-name}.command-handler.ts
â”‚   â”‚   â”‚   â””â”€â”€ {use-case-name}.command-handler.spec.ts
â”‚   â”œâ”€â”€ queries/                              # Query handlers (CQRS)
â”‚   â”‚   â”œâ”€â”€ {query-name}/
â”‚   â”‚   â”‚   â”œâ”€â”€ {query-name}.query.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ {query-name}.query-handler.ts
â”‚   â”‚   â”‚   â””â”€â”€ {query-name}.query-handler.spec.ts
â”‚   â”œâ”€â”€ event-handlers/                       # Application event handlers
â”‚   â”‚   â”œâ”€â”€ {event-name}/
â”‚   â”‚   â”‚   â”œâ”€â”€ {event-name}.event-handler.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ {event-name}.event-handler.spec.ts
â”‚   â”‚   â”‚   â””â”€â”€ {event-name}.retry-policy.ts   # Retry and error handling
â”‚   â”œâ”€â”€ sagas/                                # Distributed transaction orchestrators
â”‚   â”‚   â”œâ”€â”€ {saga-name}/
â”‚   â”‚   â”‚   â”œâ”€â”€ {saga-name}.saga.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ {saga-name}.saga.spec.ts
â”‚   â”‚   â”‚   â””â”€â”€ {saga-name}.state.ts           # Saga state management
â”‚   â”œâ”€â”€ projections/                          # Read model projections
â”‚   â”‚   â”œâ”€â”€ {projection-name}/
â”‚   â”‚   â”‚   â”œâ”€â”€ {projection-name}.projection.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ {projection-name}.projection.spec.ts
â”‚   â”‚   â”‚   â””â”€â”€ {projection-name}.rebuilder.ts # Projection rebuilding logic
â”‚   â”œâ”€â”€ dtos/                                 # Data Transfer Objects
â”‚   â”‚   â”œâ”€â”€ {dto-name}.dto.ts
â”‚   â”‚   â””â”€â”€ {dto-name}.dto.spec.ts
â”‚   â”œâ”€â”€ ports/                                # Interface definitions (Dependency Inversion)
â”‚   â”‚   â”œâ”€â”€ {repository-name}.repository.ts
â”‚   â”‚   â”œâ”€â”€ {service-name}.service.ts
â”‚   â”‚   â”œâ”€â”€ {gateway-name}.gateway.ts
â”‚   â”‚   â”œâ”€â”€ event-store.repository.ts         # Event store interface
â”‚   â”‚   â”œâ”€â”€ event-bus.service.ts              # Event bus interface
â”‚   â”‚   â”œâ”€â”€ message-broker.service.ts         # Message broker interface
â”‚   â”‚   â””â”€â”€ saga-store.repository.ts          # Saga persistence interface
â”‚   â”œâ”€â”€ services/                             # Application services
â”‚   â”‚   â”œâ”€â”€ {service-name}.service.ts
â”‚   â”‚   â”œâ”€â”€ {service-name}.service.spec.ts
â”‚   â”‚   â”œâ”€â”€ event-sourcing.service.ts         # Event sourcing coordination
â”‚   â”‚   â””â”€â”€ idempotency.service.ts            # Idempotency handling
â”‚   â”œâ”€â”€ events/                               # Application events
â”‚   â”‚   â”œâ”€â”€ {event-name}.event.ts
â”‚   â”‚   â”œâ”€â”€ {event-name}.event.spec.ts
â”‚   â”‚   â””â”€â”€ {event-name}.integration-event.ts # Cross-bounded context events
â”‚   â””â”€â”€ policies/                             # Event processing policies
â”‚       â”œâ”€â”€ retry.policy.ts
â”‚       â”œâ”€â”€ dead-letter.policy.ts
â”‚       â””â”€â”€ idempotency.policy.ts
â”œâ”€â”€ infrastructure/                           # External concerns implementation
â”‚   â”œâ”€â”€ {module-name}-infrastructure.module.ts # Infrastructure module definition
â”‚   â”œâ”€â”€ persistance/                          # Data persistence implementations
â”‚   â”‚   â”œâ”€â”€ in-memory/
â”‚   â”‚   â”‚   â”œâ”€â”€ in-memory-persistance.module.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ {entity-name}-in-memory.entity.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ {repository-name}-in-memory.repository.ts
â”‚   â”‚   â”‚   â””â”€â”€ event-store/
â”‚   â”‚   â”‚       â””â”€â”€ in-memory-event-store.repository.ts
â”‚   â”‚   â”œâ”€â”€ prisma/
â”‚   â”‚   â”‚   â”œâ”€â”€ prisma-persistance.module.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ {entity-name}-prisma.entity.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ {repository-name}-prisma.repository.ts
â”‚   â”‚   â”‚   â””â”€â”€ event-store/
â”‚   â”‚   â”‚       â”œâ”€â”€ prisma-event-store.repository.ts
â”‚   â”‚   â”‚       â””â”€â”€ outbox.entity.ts          # Outbox pattern implementation
â”‚   â”‚   â””â”€â”€ event-sourcing/
â”‚   â”‚       â”œâ”€â”€ event-sourcing.module.ts
â”‚   â”‚       â”œâ”€â”€ repositories/
â”‚   â”‚       â”‚   â”œâ”€â”€ event-store.repository.impl.ts
â”‚   â”‚       â”‚   â””â”€â”€ snapshot-store.repository.impl.ts
â”‚   â”‚       â””â”€â”€ services/
â”‚   â”‚           â”œâ”€â”€ event-replay.service.impl.ts
â”‚   â”‚           â””â”€â”€ snapshot.service.impl.ts
â”‚   â”œâ”€â”€ messaging/                            # Event and message handling
â”‚   â”‚   â”œâ”€â”€ kafka/
â”‚   â”‚   â”‚   â”œâ”€â”€ kafka-messaging.module.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ producers/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ kafka-event-publisher.service.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ kafka-command-publisher.service.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ consumers/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ kafka-event-consumer.service.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ kafka-dead-letter-consumer.service.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ kafka.config.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ topic.config.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ consumer-group.config.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ serializers/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ avro.serializer.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ json.serializer.ts
â”‚   â”‚   â”‚   â””â”€â”€ middleware/
â”‚   â”‚   â”‚       â”œâ”€â”€ retry.middleware.ts
â”‚   â”‚   â”‚       â”œâ”€â”€ dead-letter.middleware.ts
â”‚   â”‚   â”‚       â””â”€â”€ idempotency.middleware.ts
â”‚   â”‚   â”œâ”€â”€ in-memory/
â”‚   â”‚   â”‚   â”œâ”€â”€ in-memory-messaging.module.ts
â”‚   â”‚   â”‚   â””â”€â”€ in-memory-event-bus.service.ts
â”‚   â”‚   â””â”€â”€ rabbitmq/                         # Alternative messaging system
â”‚   â”‚       â”œâ”€â”€ rabbitmq-messaging.module.ts
â”‚   â”‚       â””â”€â”€ rabbitmq-event-bus.service.ts
â”‚   â”œâ”€â”€ cache/                                # Caching implementations
â”‚   â”‚   â”œâ”€â”€ noop/
â”‚   â”‚   â”‚   â””â”€â”€ noop-cache.module.ts
â”‚   â”‚   â”œâ”€â”€ in-memory/
â”‚   â”‚   â”‚   â””â”€â”€ in-memory-cache.module.ts
â”‚   â”‚   â””â”€â”€ redis/
â”‚   â”‚       â”œâ”€â”€ redis-cache.module.ts
â”‚   â”‚       â””â”€â”€ redis-projection-cache.service.ts # Projection caching
â”‚   â”œâ”€â”€ monitoring/                           # Observability implementations
â”‚   â”‚   â”œâ”€â”€ metrics/
â”‚   â”‚   â”‚   â”œâ”€â”€ event-metrics.service.ts
â”‚   â”‚   â”‚   â””â”€â”€ saga-metrics.service.ts
â”‚   â”‚   â””â”€â”€ tracing/
â”‚   â”‚       â”œâ”€â”€ event-tracing.service.ts
â”‚   â”‚       â””â”€â”€ distributed-tracing.service.ts
â”‚   â”œâ”€â”€ schema-registry/                      # Event schema management
â”‚   â”‚   â”œâ”€â”€ avro/
â”‚   â”‚   â”‚   â”œâ”€â”€ avro-schema-registry.module.ts
â”‚   â”‚   â”‚   â””â”€â”€ avro-schema-registry.service.ts
â”‚   â”‚   â””â”€â”€ json-schema/
â”‚   â”‚       â””â”€â”€ json-schema-registry.service.ts
â”‚   â”œâ”€â”€ services/                             # External service implementations
â”‚   â”‚   â”œâ”€â”€ {service-name}.service.impl.ts
â”‚   â”‚   â””â”€â”€ {service-name}.service.impl.spec.ts
â”‚   â”œâ”€â”€ decorators/                           # Infrastructure decorators
â”‚   â”‚   â”œâ”€â”€ {decorator-name}.decorator.ts
â”‚   â”‚   â”œâ”€â”€ transactional.decorator.ts
â”‚   â”‚   â”œâ”€â”€ idempotent.decorator.ts
â”‚   â”‚   â””â”€â”€ saga-orchestrates.decorator.ts
â”‚   â”œâ”€â”€ guards/                               # Security guards
â”‚   â”‚   â”œâ”€â”€ {guard-name}/
â”‚   â”‚   â”‚   â”œâ”€â”€ {guard-name}.guard.ts
â”‚   â”‚   â”‚   â””â”€â”€ {guard-name}.guard.spec.ts
â”‚   â”‚   â””â”€â”€ event-authorization.guard.ts
â”‚   â””â”€â”€ providers/                            # External providers (APIs, etc.)
â”‚       â””â”€â”€ {provider-name}/
â”‚           â”œâ”€â”€ {provider-name}.provider.ts
â”‚           â””â”€â”€ {provider-name}.provider.spec.ts
â””â”€â”€ presenters/                               # Interface adapters
    â”œâ”€â”€ http/                                 # HTTP controllers
    â”‚   â”œâ”€â”€ controllers/
    â”‚   â”‚   â”œâ”€â”€ {controller-name}.controller.ts
    â”‚   â”‚   â””â”€â”€ {controller-name}.controller.spec.ts
    â”‚   â”œâ”€â”€ dtos/
    â”‚   â”‚   â”œâ”€â”€ requests/
    â”‚   â”‚   â”‚   â””â”€â”€ {request-name}.request.dto.ts
    â”‚   â”‚   â””â”€â”€ responses/
    â”‚   â”‚       â””â”€â”€ {response-name}.response.dto.ts
    â”‚   â”œâ”€â”€ guards/
    â”‚   â”‚   â”œâ”€â”€ {guard-name}.guard.ts
    â”‚   â”‚   â””â”€â”€ {guard-name}.guard.spec.ts
    â”‚   â””â”€â”€ webhooks/                         # Webhook handlers for external events
    â”‚       â”œâ”€â”€ {webhook-name}.webhook.ts
    â”‚       â””â”€â”€ {webhook-name}.webhook.spec.ts
    â”œâ”€â”€ graphql/                              # GraphQL resolvers
    â”‚   â”œâ”€â”€ resolvers/
    â”‚   â”‚   â”œâ”€â”€ {resolver-name}.resolver.ts
    â”‚   â”‚   â””â”€â”€ {resolver-name}.resolver.spec.ts
    â”‚   â”œâ”€â”€ dtos/
    â”‚   â”‚   â”œâ”€â”€ requests/
    â”‚   â”‚   â”‚   â””â”€â”€ {request-name}.request.dto.ts
    â”‚   â”‚   â””â”€â”€ responses/
    â”‚   â”‚       â””â”€â”€ {response-name}.response.dto.ts
    â”‚   â”œâ”€â”€ guards/
    â”‚   â”‚   â”œâ”€â”€ {guard-name}.guard.ts
    â”‚   â”‚   â””â”€â”€ {guard-name}.guard.spec.ts
    â”‚   â””â”€â”€ subscriptions/                    # Real-time GraphQL subscriptions
    â”‚       â”œâ”€â”€ {subscription-name}.subscription.ts
    â”‚       â””â”€â”€ {subscription-name}.subscription.spec.ts
    â””â”€â”€ events/                               # Event-driven presenters
        â”œâ”€â”€ consumers/
        â”‚   â”œâ”€â”€ {event-consumer-name}.consumer.ts
        â”‚   â””â”€â”€ {event-consumer-name}.consumer.spec.ts
        â””â”€â”€ publishers/
            â”œâ”€â”€ {event-publisher-name}.publisher.ts
            â””â”€â”€ {event-publisher-name}.publisher.spec.ts
```

## ğŸ“‹ Layer Responsibilities

### ğŸ›ï¸ Domain Layer

**Purpose**: Contains business logic and domain knowledge
**Dependencies**: None (pure business logic)

- **Entities**: Core business objects with identity and lifecycle
- **Value Objects**: Immutable objects defined by their properties
- **Domain Events**: Business events that occurred in the domain with schemas
- **Aggregates**: Consistency boundaries and transaction boundaries
- **Domain Services**: Business logic that doesn't belong to a single entity
- **Factories**: Complex object creation logic
- **Exceptions**: Domain-specific error conditions
- **Primitives**: Basic types used across the domain
- **Constants**: Domain-level constants

**Rules**:

- No dependencies on other layers
- Contains only business logic
- Entities must implement proper encapsulation
- Value Objects must be immutable
- All business rules must be enforced here
- Aggregates define transaction boundaries
- Domain events must have versioned schemas

### ğŸ”„ Application Layer

**Purpose**: Orchestrates use cases and coordinates domain objects
**Dependencies**: Domain layer only

- **Commands/CommandHandlers**: Write operations (CQRS pattern)
- **Queries/QueryHandlers**: Read operations (CQRS pattern)
- **Event Handlers**: React to domain and integration events
- **Sagas**: Orchestrate distributed transactions and processes
- **Projections**: Build read models from event streams
- **DTOs**: Data transfer between layers
- **Ports**: Interface definitions for external dependencies
- **Services**: Application-specific services including event sourcing
- **Events**: Application-level and integration events
- **Policies**: Event processing, retry, and error handling policies

**Rules**:

- Orchestrates domain objects
- Implements use cases and business processes
- Depends only on domain layer
- Defines interfaces for infrastructure (ports)
- No business logic, only coordination
- Manages eventual consistency through events
- Implements saga patterns for distributed transactions
- Handles idempotency and exactly-once processing

### ğŸ”§ Infrastructure Layer

**Purpose**: Implements technical concerns and external dependencies
**Dependencies**: Application and Domain layers

- **Persistence**: Database implementations with event store
- **Messaging**: Kafka, RabbitMQ, and other message brokers
- **Event Sourcing**: Event store, snapshots, and replay mechanisms
- **Cache**: Caching strategies including projection caching
- **Schema Registry**: Event schema management and evolution
- **Monitoring**: Metrics, tracing, and observability
- **Services**: External service implementations
- **Providers**: Third-party integrations
- **Decorators**: Cross-cutting concerns (transactional, idempotent)
- **Guards**: Security implementations

**Rules**:

- Implements ports defined in application layer
- Contains all framework-specific code
- Handles external integrations
- Must be swappable through dependency injection
- Implements outbox pattern for transactional integrity
- Provides exactly-once delivery guarantees
- Handles schema evolution and backward compatibility
- Implements circuit breakers and retry mechanisms

### ğŸŒ Presenters Layer

**Purpose**: Handles external interfaces (HTTP, GraphQL, Events, CLI, etc.)
**Dependencies**: Application layer only

- **Controllers**: HTTP endpoint handlers
- **Resolvers**: GraphQL resolver handlers
- **Webhooks**: External system integration handlers
- **Event Consumers**: Kafka consumer handlers
- **Event Publishers**: Event publication interfaces
- **Subscriptions**: Real-time data subscriptions
- **DTOs**: Input/output data structures
- **Guards**: Presentation-level security
- **Middleware**: Request/response processing

**Rules**:

- Only input/output mapping
- No business logic
- Depends only on application layer
- Handles serialization/deserialization
- Manages event routing and transformation
- Implements at-least-once delivery semantics
- Provides idempotency keys for external consumers

## ğŸš€ Event-Driven Architecture Patterns

### ğŸ”„ Event Sourcing

```typescript
/**
 * Event sourcing implementation pattern
 * Store all changes as immutable events
 */
export interface EventStore {
  append(
    streamId: string,
    events: DomainEvent[],
    expectedVersion?: number,
  ): Promise<void>;
  getEvents(streamId: string, fromVersion?: number): Promise<DomainEvent[]>;
  getSnapshot(streamId: string): Promise<Snapshot | null>;
  saveSnapshot(streamId: string, snapshot: Snapshot): Promise<void>;
}

/**
 * Aggregate reconstruction from events
 */
export abstract class EventSourcedAggregate {
  protected version = 0;
  private uncommittedEvents: DomainEvent[] = [];

  static fromHistory<T extends EventSourcedAggregate>(
    events: DomainEvent[],
  ): T {
    const aggregate = new (this as any)();
    events.forEach((event) => aggregate.applyEvent(event));
    aggregate.version = events.length;
    return aggregate;
  }

  protected applyEvent(event: DomainEvent): void {
    this.apply(event);
    this.version++;
  }

  protected addEvent(event: DomainEvent): void {
    this.apply(event);
    this.uncommittedEvents.push(event);
  }

  getUncommittedEvents(): DomainEvent[] {
    return [...this.uncommittedEvents];
  }

  markEventsAsCommitted(): void {
    this.uncommittedEvents = [];
  }

  protected abstract apply(event: DomainEvent): void;
}
```

### ğŸ“¦ Outbox Pattern

```typescript
/**
 * Outbox pattern for transactional consistency
 * Ensures events are published exactly once
 */
@Entity()
export class OutboxEvent {
  @PrimaryColumn()
  id: string;

  @Column()
  aggregateId: string;

  @Column()
  eventType: string;

  @Column('json')
  eventData: object;

  @Column()
  createdAt: Date;

  @Column({ nullable: true })
  processedAt?: Date;

  @Column({ default: 0 })
  retryCount: number;
}

export class OutboxService {
  async publishUnprocessedEvents(): Promise<void> {
    const events = await this.outboxRepository.findUnprocessed();

    for (const event of events) {
      try {
        await this.eventBus.publish(event);
        await this.outboxRepository.markAsProcessed(event.id);
      } catch (error) {
        await this.outboxRepository.incrementRetry(event.id);
        if (event.retryCount >= MAX_RETRIES) {
          await this.deadLetterQueue.send(event);
        }
      }
    }
  }
}
```

### ğŸ­ Saga Pattern

```typescript
/**
 * Saga pattern for distributed transactions
 * Manages long-running business processes
 */
export abstract class Saga {
  protected sagaId: string;
  protected state: SagaState;
  protected compensations: Array<() => Promise<void>> = [];

  abstract handle(event: DomainEvent): Promise<void>;

  protected async executeStep<T>(
    action: () => Promise<T>,
    compensation: () => Promise<void>,
  ): Promise<T> {
    try {
      const result = await action();
      this.compensations.push(compensation);
      return result;
    } catch (error) {
      await this.compensate();
      throw error;
    }
  }

  protected async compensate(): Promise<void> {
    const compensations = [...this.compensations].reverse();

    for (const compensation of compensations) {
      try {
        await compensation();
      } catch (error) {
        // Log compensation failure but continue
        console.error('Compensation failed:', error);
      }
    }

    this.compensations = [];
  }
}
```

### ğŸ“Š Projection Pattern

```typescript
/**
 * Projection pattern for read models
 * Build optimized views from event streams
 */
export abstract class Projection {
  abstract readonly projectionName: string;

  abstract project(event: DomainEvent): Promise<void>;

  async rebuild(fromVersion?: number): Promise<void> {
    // Clear current projection
    await this.clear();

    // Replay all events
    const events = await this.eventStore.getAllEvents(fromVersion);

    for (const event of events) {
      await this.project(event);
    }
  }

  protected abstract clear(): Promise<void>;
}
```

## ğŸ”§ Module Integration Pattern

```typescript
// Main module with event-driven capabilities
@Module({})
export class {ModuleName}Module {
  static forRoot(options: ApplicationBootstrapOptions): DynamicModule {
    return {
      module: {ModuleName}Module,
      imports: [
        {ModuleName}DomainModule,
        {ModuleName}ApplicationModule,
        {ModuleName}InfrastructureModule.use(
          options.databaseDriver,
          options.cacheDriver,
          options.messagingDriver,
          options.eventSourcingEnabled,
        ),
      ],
      exports: [{ModuleName}ApplicationModule, {ModuleName}InfrastructureModule],
    };
  }
}

// Application module with saga and projection support
@Module({})
export class {ModuleName}ApplicationModule {
  static withInfrastructure(
    infrastructureModule: Type | DynamicModule,
    options: ApplicationBootstrapOptions,
  ) {
    const providers = [
      ...this.getCommandHandlers(),
      ...this.getQueryHandlers(),
      ...this.getEventHandlers(),
      ...this.getSagas(),
      ...this.getProjections(),
    ];

    return {
      module: {ModuleName}ApplicationModule,
      imports: [infrastructureModule],
      providers,
      exports: providers,
    };
  }

  private static getCommandHandlers(): Provider[] {
    return [
      // Command handlers
    ];
  }

  private static getQueryHandlers(): Provider[] {
    return [
      // Query handlers
    ];
  }

  private static getEventHandlers(): Provider[] {
    return [
      // Event handlers
    ];
  }

  private static getSagas(): Provider[] {
    return [
      // Saga orchestrators
    ];
  }

  private static getProjections(): Provider[] {
    return [
      // Projection builders
    ];
  }
}

// Infrastructure module with messaging support
@Module({})
export class {ModuleName}InfrastructureModule {
  static use(
    databaseDriver: 'in-memory' | 'prisma',
    cacheDriver: 'in-memory' | 'noop' | 'redis',
    messagingDriver: 'in-memory' | 'kafka' | 'rabbitmq',
    eventSourcingEnabled: boolean = false,
  ) {
    const persistenceModule = this.selectPersistenceModule(databaseDriver);
    const cacheModule = this.selectCacheModule(cacheDriver);
    const messagingModule = this.selectMessagingModule(messagingDriver);
    const eventSourcingModule = eventSourcingEnabled
      ? this.selectEventSourcingModule(databaseDriver)
      : null;

    return {
      module: {ModuleName}InfrastructureModule,
      imports: [
        persistenceModule,
        cacheModule,
        messagingModule,
        ...(eventSourcingModule ? [eventSourcingModule] : [])
      ],
      exports: [
        persistenceModule,
        cacheModule,
        messagingModule,
        ...(eventSourcingModule ? [eventSourcingModule] : [])
      ],
    };
  }

  private static selectMessagingModule(driver: string) {
    switch (driver) {
      case 'kafka':
        return KafkaMessagingModule;
      case 'rabbitmq':
        return RabbitMQMessagingModule;
      default:
        return InMemoryMessagingModule;
    }
  }

  private static selectEventSourcingModule(databaseDriver: string) {
    return EventSourcingModule.forDatabase(databaseDriver);
  }
}
```

## ğŸ“‚ Shared Components Structure

```
shared/
â”œâ”€â”€ shared.module.ts
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ exceptions/
â”‚   â”‚   â”œâ”€â”€ domain.exception.ts           # Base domain exception
â”‚   â”‚   â”œâ”€â”€ aggregate-not-found.exception.ts
â”‚   â”‚   â””â”€â”€ concurrency.exception.ts
â”‚   â”œâ”€â”€ events/
â”‚   â”‚   â”œâ”€â”€ domain-event.interface.ts
â”‚   â”‚   â”œâ”€â”€ integration-event.interface.ts
â”‚   â”‚   â””â”€â”€ event-metadata.ts
â”‚   â””â”€â”€ value-objects/
â”‚       â”œâ”€â”€ base.value-object.ts
â”‚       â”œâ”€â”€ event-id.value-object.ts
â”‚       â””â”€â”€ correlation-id.value-object.ts
â”œâ”€â”€ infrastructure/
â”‚   â”œâ”€â”€ shared-infrastructure.module.ts
â”‚   â”œâ”€â”€ filters/
â”‚   â”‚   â”œâ”€â”€ domain-exception.filter.ts   # Global exception filter
â”‚   â”‚   â””â”€â”€ event-exception.filter.ts
â”‚   â”œâ”€â”€ messaging/
â”‚   â”‚   â”œâ”€â”€ event-bus.interface.ts
â”‚   â”‚   â”œâ”€â”€ message-broker.interface.ts
â”‚   â”‚   â””â”€â”€ event-serializer.interface.ts
â”‚   â”œâ”€â”€ monitoring/
â”‚   â”‚   â”œâ”€â”€ metrics.service.ts
â”‚   â”‚   â””â”€â”€ distributed-tracing.service.ts
â”‚   â”œâ”€â”€ redis/
â”‚   â”‚   â””â”€â”€ redis.module.ts               # Shared Redis configuration
â”‚   â””â”€â”€ patterns/
â”‚       â”œâ”€â”€ outbox/
â”‚       â”‚   â”œâ”€â”€ outbox.module.ts
â”‚       â”‚   â””â”€â”€ outbox.service.ts
â”‚       â”œâ”€â”€ saga/
â”‚       â”‚   â”œâ”€â”€ saga.module.ts
â”‚       â”‚   â”œâ”€â”€ saga.orchestrator.ts
â”‚       â”‚   â””â”€â”€ saga-store.interface.ts
â”‚       â””â”€â”€ event-sourcing/
â”‚           â”œâ”€â”€ event-sourcing.module.ts
â”‚           â”œâ”€â”€ event-store.interface.ts
â”‚           â””â”€â”€ snapshot-store.interface.ts
â””â”€â”€ common/
    â”œâ”€â”€ constants/
    â”‚   â”œâ”€â”€ event-types.constant.ts        # Global event type constants
    â”‚   â”œâ”€â”€ topic-names.constant.ts        # Kafka topic names
    â”‚   â””â”€â”€ retry-policies.constant.ts
    â”œâ”€â”€ interfaces/
    â”‚   â”œâ”€â”€ application-bootstrap-options.interface.ts
    â”‚   â”œâ”€â”€ event-sourcing-options.interface.ts
    â”‚   â””â”€â”€ messaging-options.interface.ts
    â””â”€â”€ decorators/
        â”œâ”€â”€ event-handler.decorator.ts
        â”œâ”€â”€ saga-start.decorator.ts
        â”œâ”€â”€ saga-orchestrates.decorator.ts
        â””â”€â”€ projection.decorator.ts
```

## ğŸ¯ Naming Conventions

### Core Components

- **Modules**: `{domain-name}.module.ts`
- **Entities**: `{entity-name}.ts`
- **Aggregates**: `{aggregate-name}.aggregate.ts`
- **Value Objects**: `{module-name}-{property-name}.value-object.ts`

### CQRS Components

- **Commands**: `{action-name}.command.ts`
- **Command Handlers**: `{action-name}.command-handler.ts`
- **Queries**: `{query-name}.query.ts`
- **Query Handlers**: `{query-name}.query-handler.ts`

### Event-Driven Components

- **Domain Events**: `{event-name}.domain-event.ts`
- **Integration Events**: `{event-name}.integration-event.ts`
- **Event Handlers**: `{event-name}.event-handler.ts`
- **Event Schemas**: `{event-name}.schema.ts`

### Distributed Patterns

- **Sagas**: `{saga-name}.saga.ts`
- **Projections**: `{projection-name}.projection.ts`
- **Event Consumers**: `{consumer-name}.consumer.ts`
- **Event Publishers**: `{publisher-name}.publisher.ts`

### Infrastructure

- **Repositories**: `{entity-name}.repository.ts`
- **Services**: `{service-name}.service.ts`
- **Controllers**: `{resource-name}.controller.ts`
- **Middleware**: `{middleware-name}.middleware.ts`

## ğŸ§ª Testing Strategy

### Unit Testing

- **Domain Tests**: Focus on business logic and invariants
- **Application Tests**: Test use case orchestration and event handling
- **Infrastructure Tests**: Test external integrations and messaging

### Integration Testing

- **Event Flow Tests**: Test complete event flows across bounded contexts
- **Saga Tests**: Test distributed transaction scenarios
- **Projection Tests**: Test read model consistency

### End-to-End Testing

- **Message Replay Tests**: Test event replay scenarios
- **Failure Recovery Tests**: Test system resilience
- **Performance Tests**: Test under load with high event volumes

### Event-Specific Testing

```typescript
describe('Event Flow Testing', () => {
  it('should process events in correct order', async () => {
    // Arrange: Set up event stream
    const events = [event1, event2, event3];

    // Act: Process events
    await eventProcessor.processEvents(events);

    // Assert: Verify final state
    expect(await projectionRepository.getState()).toEqual(expectedState);
  });

  it('should handle event replay correctly', async () => {
    // Test projection rebuilding from events
  });

  it('should ensure exactly-once processing', async () => {
    // Test idempotency mechanisms
  });
});
```

## ğŸ“‹ Implementation Rules

### Core Architecture Rules

1. **Dependency Direction**: Always inward (Infrastructure â†’ Application â†’ Domain)
2. **Interface Segregation**: Create specific interfaces for each use case
3. **Single Responsibility**: Each class/module has one reason to change
4. **Open/Closed**: Open for extension, closed for modification
5. **Dependency Inversion**: Depend on abstractions, not concretions

### Event-Driven Rules

6. **Event Immutability**: Events must be immutable once created
7. **Event Versioning**: All events must support schema evolution
8. **Exactly-Once Processing**: Implement idempotency for all event handlers
9. **Event Ordering**: Maintain event ordering within aggregates
10. **Eventual Consistency**: Design for eventual consistency across bounded contexts

### Distributed System Rules

11. **Saga Isolation**: Sagas must handle concurrent execution
12. **Compensation Logic**: All saga steps must have compensation actions
13. **Circuit Breakers**: Implement circuit breakers for external dependencies
14. **Retry Policies**: Define clear retry and backoff strategies
15. **Dead Letter Queues**: Handle poison messages appropriately

### Observability Rules

16. **Distributed Tracing**: Trace requests across service boundaries
17. **Event Metrics**: Monitor event processing latency and throughput
18. **Saga Monitoring**: Track saga execution status and failures
19. **Projection Lag**: Monitor projection processing delays
20. **Schema Evolution**: Track schema changes and compatibility

This architecture ensures scalability, maintainability, and testability while following DDD principles, clean architecture patterns, and advanced event-driven architecture for distributed systems with Kafka and similar messaging platforms.

This architecture ensures scalability, maintainability, and testability while following DDD principles and clean architecture patterns.
